#!/usr/bin/env python

from __future__ import division, print_function
import argparse
import collections
import logging
import math
import re
import sys
import subprocess
import time
from audiotest.recorder import Recorder
from audiotest.gst_audio_object import GstAudioObject
#Trick to prevent gst from hijacking argv parsing
argv = sys.argv
sys.argv = []
try:
    import gobject
    import gst
    from gobject import GError
except ImportError:
    print("Can't import module: %s. it may not be available for this"
          "version of Python, which is: " % sys.exc_info()[1], file=sys.stderr)
    print((sys.version), file=sys.stderr)
    sys.exit(127)
sys.argv = argv


#Frequency bands for FFT
BINS = 256
#How often to take a sample and do FFT on it.
FFT_INTERVAL = 100000000  # In nanoseconds, so this is every 1/10th second
#Sampling frequency. The effective maximum frequency we can analyze is
#half of this (see Nyquist's theorem)
SAMPLING_FREQUENCY = 44100
#The default test frequency should be in the middle of the frequency band
#that delimits the first and second thirds of the frequency range.
#That gives a not-so-ear-piercing tone and should ensure there's no
#spillout to neighboring frequency bands.
DEFAULT_TEST_FREQUENCY = (SAMPLING_FREQUENCY / (2 * BINS)) * int(BINS / 3) - \
                         (SAMPLING_FREQUENCY / (2 * BINS)) / 2
#only sample a signal when peak level is in this range (in dB attenuation,
#0 means no attenuation (and horrible clipping).
REC_LEVEL_RANGE = (-2.0, -12.0)
#For our test signal to be considered present, it has to be this much higher
#base level (minimum magnitude). This is in dB.
MAGNITUDE_THRESHOLD = 2.5


def process_arguments():
    description = """
        Plays a single frequency through the default output, then records on
        the default input device. Analyzes the recorded signal to test for
        presence of the played frequency, if present it exits with success.
    """
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument("-t", "--time",
            dest='test_duration',
            action='store',
            default=30,
            type=int,
            help="""Maximum test duration, default %(default)s seconds.
                    It may exit sooner if it determines it has enough data.""")
    parser.add_argument("-a", "--audio",
            action='store',
            default=None,
            type=str,
            help="File to save recorded audio in .wav format")
    parser.add_argument("-q", "--quiet",
            action='store_true',
            default=False,
            help="Be quiet, no output unless there's an error.")
    parser.add_argument("-d", "--debug",
            action='store_true',
            default=False,
            help="Debugging output")
    parser.add_argument("-f", "--frequency",
            action='store',
            default=DEFAULT_TEST_FREQUENCY,
            type=int,
            help="Frequency for test signal, default %(default)s Hz")
    parser.add_argument("-u", "--spectrum",
            action='store',
            type=str,
            help="""File to save spectrum information for plotting
                    (one frequency/magnitude pair per line)""")
    return parser.parse_args()


#
def main():
    #Get arguments.
    args = process_arguments()

    #Setup logging
    level = logging.INFO
    if args.debug:
        level = logging.DEBUG
    if args.quiet:
        level = logging.ERROR
    logging.basicConfig(level=level)
    try:
        #Launches recording pipeline. I need to hook up into the gst
        #messages.
        recorder = Recorder(logger=logging)
        #Just launches the playing pipeline
        player = Player(frequency=args.frequency, logger=logging)
    except GError:
        logging.critical("Unable to initialize GStreamer pipelines")
        sys.exit(127)

    #This just receives a process feedback and tells me how much to change to
    #achieve the setpoint
    pidctrl = PIDController(Kp=0.7, Ki=.01, Kd=0.01,
                            setpoint=REC_LEVEL_RANGE[0])
    pidctrl.set_change_limit(5)
    #This  gathers spectrum data.
    analyzer = SpectrumAnalyzer(points=BINS,
                                sampling_frequency=SAMPLING_FREQUENCY)
    #this receives 'buffer' messages and gathers raw audio data
    rawaudio = GStreamerRawAudioRecorder()

    #Volume controllers actually set volumes for their device types.
    #we should at least issue a warning
    recorder.volumecontroller = PAVolumeController(type='input',
                                                   logger=logging)
    if not recorder.volumecontroller.get_identifier():
        logging.warning("Unable to get input volume control identifier. "
                       "Test results will probably be invalid")
    recorder.volumecontroller.set_volume(0)
    recorder.volumecontroller.mute(False)

    player.volumecontroller = PAVolumeController(type='output',
                                                 logger=logging)
    if not player.volumecontroller.get_identifier():
        logging.warning("Unable to get output volume control identifier. "
                       "Test results will probably be invalid")
    player.volumecontroller.set_volume(70)
    player.volumecontroller.mute(False)

    #This handles the messages from gstreamer and orchestrates
    #the passed volume controllers, pid controller and spectrum analyzer
    #accordingly.
    gmh = GStreamerMessageHandler(rec_level_range=REC_LEVEL_RANGE,
                                  logger=logging,
                                  volumecontroller=recorder.volumecontroller,
                                  pidcontroller=pidctrl,
                                  spectrum_analyzer=analyzer)

    #I need to tell the recorder which method will handle messages.
    recorder.register_message_handler(gmh.bus_message_handler)
    recorder.register_buffer_handler(rawaudio.buffer_handler)

    #Create the loop and add a few triggers
    gobject.threads_init()
    loop = gobject.MainLoop()
    gobject.timeout_add_seconds(0, player.start)
    gobject.timeout_add_seconds(0, recorder.start)
    gobject.timeout_add_seconds(args.test_duration, loop.quit)

    # Tell the gmh which method to call when enough samples are collected
    gmh.set_quit_method(loop.quit)

    loop.run()

    #When the loop ends, set things back to reasonable states
    player.stop()
    recorder.stop()
    player.volumecontroller.set_volume(50)
    recorder.volumecontroller.set_volume(10)

    #See if data gathering was successful.
    test_band = analyzer.frequency_band_for(args.frequency)
    candidate_bands = analyzer.frequencies_with_peak_magnitude(MAGNITUDE_THRESHOLD)
    for band in candidate_bands:
        logging.debug("Band (%.2f,%.2f) contains a magnitude peak" %
                      analyzer.frequencies_for_band(band))
    if test_band in candidate_bands:
        freqs_for_band = analyzer.frequencies_for_band(test_band)
        logging.info("PASS: Test frequency of %s in band (%.2f, %.2f) "
              "which contains a magnitude peak" %
            ((args.frequency,) + freqs_for_band))
        return_value = 0
    else:
        logging.info("FAIL: Test frequency of %s is not in one of the "
              "bands with magnitude peaks" % args.frequency)
        return_value = 1
    #Is the microphone broken?
    if len(set(analyzer.spectrum)) <= 1:
        logging.info("WARNING: Microphone seems broken, didn't even "
                     "record ambient noise")

    #Write some files to disk for later analysis
    if args.audio:
        logging.info("Saving recorded audio as %s" % args.audio)
        if not FileDumper().write_to_file(args.audio,
                                          [rawaudio.get_raw_audio()]):
            logging.error("Couldn't save recorded audio", file=sys.stderr)

    if args.spectrum:
        logging.info("Saving spectrum data for plotting as %s" %
                     args.spectrum)
        if not FileDumper().write_to_file(args.spectrum,
                                       ["%s,%s" % t for t in
                                        zip(analyzer.frequencies,
                                            analyzer.spectrum)]):
            logging.error("Couldn't save spectrum data for plotting",
                          file=sys.stderr)

    return return_value

if __name__ == "__main__":
    sys.exit(main())
